<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="author" content="Manuel Freiholz">
	<meta name="keywords" content="programming c++ go golang php projects books">

	<title>Network Protocol Parsing with C&#43;&#43; | M. Freiholz Software Development</title>

	<link href="/posts/index.xml" rel="alternate" type="application/rss+xml" title="mfreiholz.de" />
	<link href="/posts/index.xml" rel="feed" type="application/rss+xml" title="mfreiholz.de" />
</head>

<body>

	<div id="site-header" class="container">
		<div class="title">M. Freiholz</div>
		<div class="subtitle">Software Development</div>
	</div>

	<div id="site-navigation" class="container">
		<div class="row">
			<div class="col-md-8">
				<ul>
					<li><a href="/">Home</a></li>
					<li><a href="/work/">Products</a></li>
					<li><a href="/donate/">Support Me</a></li>
				</ul>
			</div>
			<div class="col-md-4">
				<div class="right">
					<div class="social">
						<a href="https://www.instagram.com/mfreiholz/" alt="Instagram" title="Me on Instagram"><img src="/images/instagram.png" height="32"></a>
						<a href="https://twitter.com/mfreiholz/" alt="Twitter" title="Me on Twitter"><img src="/images/twitter-48-black.png" height="38"></a>
					</div>
				</div>
			</div>

		</div>
		

	</div>
	


<div id="site-content" class="container md">

    <div class="post">
	<h2 class="post-title"><a href="/posts/network-protocol-parser/">Network Protocol Parsing with C&#43;&#43;</a></h2>
	<div class="post-content"><p>I&rsquo;ve implemented a lot of network protocols lately, for work and private projects. I&rsquo;d like to show you the basic implementation I mostly use and has been proven to be very resource friendly, fast and stable.
</p>

<h2 id="the-protocol">The Protocol</h2>

<p>At the beginning there is the protocol definition. For this example I will use a simple single frame/packet based protocol to exchanges data between two endpoints (e.g.: client and server).</p>

<h3 id="the-packet">The Packet</h3>

<pre><code class="language-cpp">// packet.h
#pragma once
#include &lt;stdint.h&gt;
#include &lt;vector&gt;

#ifdef _WIN32
#include &lt;WinSock2.h&gt;
#else
#include &lt;arpa/inet.h&gt;
#endif

class Packet
{
public:
    Packet();
    ~Packet();

    /*
        Serializes the packet for network transport.
        Fields are written to `buf` in network byte order (big-endian).
    */
    void serialize(std::vector&lt;uint8_t&gt;&amp; buf);

public:
    uint8_t header = 0xAF; // Marks the begin of `Packet`
    uint8_t flags = 0x00; // Custom bitmask flags.
    uint16_t type = 0x0000; // Identifies the packet's type - what is it used for.
    uint32_t size = 0x00000000; // Size of `data`.
    std::vector&lt;uint8_t&gt; data; // Custom data.
    uint8_t checksum = 0x00; // XOR checksum.
};
</code></pre>

<p>As you can see the <code>Packet</code> is very basic. It doesn&rsquo;t distinguish between request or response, but it does have different sized data types to show the correct handling of them.</p>

<p>It does have a <code>serialization()</code> method, which writes the bytes of the object into a buffer. You could write them directly to network instead, of course. The important part of the method is the conversion of fields to network-byte-order (big-endian). You should always do this whether you are developing platform independent or not. It is a convention to always send data types in big-edian byte order over network.</p>

<pre><code class="language-cpp">//packet.cpp
#include &quot;packet.h&quot;

Packet::Packet()
{}

Packet::~Packet()
{}

void
Packet::serialize(std::vector&lt;uint8_t&gt;&amp; buf)
{
    buf.push_back(header);
    buf.push_back(flags);
    buf.push_back(htons(type) &gt;&gt; 8);
    buf.push_back(htons(type) &gt;&gt; 0);
    buf.push_back(htonl(size) &gt;&gt; 24);
    buf.push_back(htonl(size) &gt;&gt; 16);
    buf.push_back(htonl(size) &gt;&gt; 8);
    buf.push_back(htonl(size) &gt;&gt; 0);
    for (auto b : data)
        buf.push_back(b);
    buf.push_back(checksum);
}
</code></pre>

<h3 id="the-parser">The Parser</h3>

<p>The <code>Parser</code> is also very simple and only needs a single method to work.</p>

<pre><code class="language-cpp">// parser.h
#pragma once
#include &quot;packet.h&quot;

class Parser
{
public:
    /*
        \param data
            The buffer of data which the function parses.
        \param len
            The len of `data` buffer.
        \param[in,out] bytesRead
            Will contain the number of bytes read by `parse()`.
            Note: It may be possible that the function returns
            before all bytes of `data` have been parsed, because
            the `packet` is complete.
        \param[in,out] packet
            Instance of `Packet` which will be filled from `data` by this  function.
    */
    bool parse(uint8_t* data, size_t len, size_t&amp; bytesRead, Packet&amp; packet);

private:
    int _step = 0;
};
</code></pre>

<p>It is implemented as a single byte by byte parser.</p>

<pre><code class="language-cpp">// parser.cpp
#include &quot;parser.h&quot;

#ifdef _WIN32
#include &lt;WinSock2.h&gt;
#else
#include &lt;arpa/inet.h&gt;
#endif

bool
Parser::parse(uint8_t* data, size_t len, size_t&amp; bytesRead, Packet&amp; packet)
{
    bytesRead = 0;
    for (size_t i = 0; i &lt; len; ++i)
    {
        const auto b = data[i];
        bytesRead++;

        switch (_step)
        {
            // Header.
            case 0:
                if (b != 0xAF)
                {
                    _step = 0;
                    continue;
                }
                packet.header = b;
                _step++;
                break;

            // Flags.
            case 1:
                packet.flags = b;
                _step++;
                break;

            // Type (2 bytes!).
            case 2:
                packet.type = uint16_t(b) &lt;&lt; 8;
                _step++;
                break;

            case 3:
                packet.type |= uint16_t(b) &lt;&lt; 0;
                packet.type = ntohs(packet.type);
                _step++;
                break;

            // Size (4 bytes!).
            case 4:
                packet.size = uint32_t(b) &lt;&lt; 24;
                _step++;
                break;

            case 5:
                packet.size |= uint32_t(b) &lt;&lt; 16;
                _step++;
                break;

            case 6:
                packet.size |= uint32_t(b) &lt;&lt; 8;
                _step++;
                break;

            case 7:
                packet.size |= uint32_t(b) &lt;&lt; 0;
                packet.size = ntohl(packet.size);
                _step++;

                packet.data.clear();
                if (packet.size &gt; 0)
                {
                    packet.data.reserve(packet.size);
                }
                else
                {
                    _step++; // Skip data step.
                }
                break;

            // Data.
            case 8:
                packet.data.push_back(b);

                if (packet.data.size() == packet.size)
                    _step++;
                break;

            // Checksum.
            case 9:
                packet.checksum = b;
                _step = 0;
                return true;

        }
    }
    return false;
}
</code></pre>

<p>The parser works based on steps/positions. As soon as the first byte matches the fixed header value of <code>0xAF</code> (<code>step=0</code>), it continues to parse packet attributes step by step and <em>byte for byte.</em> Remember this, it is important when it comes to handling multi-byte data types.</p>

<p><code>flags</code> (<code>step=1</code>) is a single-byte attribute, which can be assigned as it is.
Single-byte types doesn&rsquo;t require any kind of bit/byte order conversion.</p>

<p><code>type</code> (<code>step=2-3</code>) is a multi-byte data type and requires two bytes and an byte-order conversion to be complete. The Parser left-shifts the next two upcoming bytes into the <code>packet.type</code> attribute. After it is completely filled the Parser needs to convert the byte-order into the host-byte-order with <code>ntohs()</code>.</p>

<p><code>size</code> (step=<code>4-7</code>) is a multi-byte data type and requires four bytes and an byte-order conversion with <code>htohl()</code> to be complete. With step <code>7</code> it is complete and the <code>packet.data</code> attribute can be prepared by clearing all previous bytes and reserving enough space for the new data bytes.</p>

<p><code>data</code> (<code>step=8</code>) will be filled up until it contains <code>packet.size</code> number of bytes. It may required special handling of internal fields, based on the packet&rsquo;s type.</p>

<p><code>checksum</code> (<code>step=9</code>) is a single-byte data type. In best case scenario a checksum calculation and validation would run here. I skip it for this example.</p>

<p>Thats it. Based on your own packet format there would be more or less steps but the core functionality is always the same.</p>

<h3 id="using-it-testing">Using it, Testing</h3>

<p>Here is a small example. It serializes two packets into a buffer, which would be the network stack and parses it with <code>Parser</code>. Read the inline code comments for details.</p>

<pre><code class="language-cpp">// main.cpp
#include &quot;packet.h&quot;
#include &quot;parser.h&quot;

int main(int argc, char** argv)
{
    // Network buffer.
    std::vector&lt;uint8_t&gt; buf;

    // CLIENT SIDE
    // Serialize and send packets.
    // Instead of sending we simply write them to a buffer `buf`.

    // 1st packet.
    Packet pkt1;
    pkt1.header = 0xAF;
    pkt1.flags = 0x00;
    pkt1.type = 0x0001;
    pkt1.size = 3;
    pkt1.data = { 0x11, 0x22, 0x33 };
    pkt1.checksum = 0xFF;
    pkt1.serialize(buf);

    // Add some random invalid bytes to network buffer.
    buf.push_back(0x87);
    buf.push_back(0x09);
    buf.push_back(0x43);

    // 2nd packet.
    Packet pkt2;
    pkt2.header = 0xAF;
    pkt2.flags = 0x80;
    pkt2.type = 0x0002;
    pkt2.size = 1;
    pkt2.data = { 0x88 };
    pkt2.checksum = 0xEE;
    pkt2.serialize(buf);

    // Add some random invalid bytes to network buffer.
    buf.push_back(0x11);
    buf.push_back(0x22);
    buf.push_back(0x33);

    // SERVER SIDE
    // Parse packets from network/buffer `buf`.

    // Parsing.
    Parser parser;
    Packet packet;
    uint8_t* p = buf.data();
    size_t plen = buf.size();
    while (plen &gt; 0)
    {
        size_t bytesRead = 0;
        if (parser.parse(p, plen, bytesRead, packet))
        {
            // At this point the `packet` is complete.
            printf(&quot;INFO new packet! type=%d; size=%d\n&quot;, packet.type, packet.size);
        }
        p += bytesRead;
        plen -= bytesRead;
    }
    return 0;
}
</code></pre>

<p>You may want to read and debug the <code>main()</code> implementation very careful to fully understand how it works.</p>

<p>The sources are available on GitHub: <a href="https://github.com/mfreiholz/blog-article-sources/tree/master/network-protocol-parsing">https://github.com/mfreiholz/blog-article-sources/tree/master/network-protocol-parsing</a></p></div>
	<div class="post-info">
		
			<a href="/tags/development">Development</a> /
		
			<a href="/tags/tutorial">Tutorial</a> /
		
			<a href="/tags/c&#43;&#43;">C&#43;&#43;</a> /
		
		Aug 31
	</div>
	<div class="post-comments"></div>
</div>

    <div class="post-comments"> 
        <div id="disqus_thread"></div>
<script>
	


	

	

	(function() {  
		if (window.location.hostname == "localhost" ||
			window.location.hostname == "127.0.0.1")
			return;

		var d = document, s = d.createElement('script');
		s.src = '//mfreiholz.disqus.com/embed.js';
		s.setAttribute('data-timestamp', +new Date());
		(d.head || d.body).appendChild(s);
	})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
    </div>

</div>


<div class="container">
	<div id="site-footer">

		<div class="row">
			<div class="col-md-4">
				<ul class="links">
					<li><a href="/impressum/">Disclaimer / Impressum</a></li>
					<li>info (at) mfreiholz (dot) de</li>
				</ul>
			</div>
			<div class="col-md-4">
				Made with &#9825; mfreiholz.de
			</div>
			<div class="col-md-4">
				Support Me<br>
				<a href="/donate">Donate / Spenden</a>
			</div>
		</div>

	</div>
</div>

<link rel="stylesheet" type="text/css" href="/thirdparty/bootstrap/css/bootstrap.min.css">
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Julius+Sans+One|Lora">
<link rel="stylesheet" type="text/css" href="/css/style.css">
<link rel="stylesheet" type="text/css" href="/css/markdown.css">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


<script>
	(function (i, s, o, g, r, a, m) {
	i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
		(i[r].q = i[r].q || []).push(arguments)
	}, i[r].l = 1 * new Date(); a = s.createElement(o),
		m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
	})(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
	ga('create', 'UA-67699481-1', 'auto');
	ga('send', 'pageview');
</script>

</body>

</html>