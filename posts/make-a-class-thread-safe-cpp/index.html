<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="author" content="Manuel Freiholz">
	<meta name="keywords"
		content="programming c++ go golang rust php javascript typescript projects books blog network">

	<title>Make a class thread safe C&#43;&#43; | mfreiholz.de</title>

	<link href="/posts/index.xml" rel="alternate" type="application/rss+xml" title="mfreiholz.de" />
	<link href="/posts/index.xml" rel="feed" type="application/rss+xml" title="mfreiholz.de" />
</head>

<body>

	<header class="site-header">
		<div class="container">
			<div class="title">
				<span>#</span> mfreiholz.de
			</div>
			<nav>
				<a href="/">Home</a>
				<a href="/posts">Blog</a>
				<a href="/work">Projects</a>
			</nav>
		</div>
	</header>

	
	<div class="container">
		<div class="post">
	<div class="post-title"><a href="/posts/make-a-class-thread-safe-cpp/">Make a class thread safe C&#43;&#43;</a></div>
	<div class="post-content md"><p>You might have come across the case, that you had a simple class which got the new requirement to be thread-safe for upcoming use-cases. I have seen developers who simple wrapped all methods with a locked mutex, like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> MyClass<span style="color:#f92672">::</span>set(T val)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	mutex.lock();
</span></span><span style="display:flex;"><span>	_val <span style="color:#f92672">=</span> val;
</span></span><span style="display:flex;"><span>	mutex.unlock();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In a lot of cases this will work well and you donâ€™t have to worry about parallel access on class members. But there are some scenarios, where this simple approach does not help, instead it might critically crash your program.</p>
<p>I will show you a use-case with a simple <em>Cache</em> class.</p>
<h2 id="single-threaded-non-blocking">Single threaded, non-(b)locking</h2>
<p>First I will show the basic implementation from where we start. A simple <code>Cache1</code> class, which is meant to be used from one thread and does not use any mutex- or spin-locks.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cache1</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>CacheData<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> _map;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> contains(<span style="color:#66d9ef">int</span> key) <span style="color:#66d9ef">const</span>
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> _map.find(key) <span style="color:#f92672">!=</span> _map.end();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>CacheData<span style="color:#f92672">&gt;</span> get(<span style="color:#66d9ef">int</span> key) <span style="color:#66d9ef">const</span>
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> _map.at(key);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">int</span> key, std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>CacheData<span style="color:#f92672">&gt;</span> value)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		_map.insert(std<span style="color:#f92672">::</span>make_pair(key, value));
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>In addition to the class here is a small code sample, which shows the way the cache is beeing used.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">**</span> argv)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// fill cache
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	Cache1 cache;
</span></span><span style="display:flex;"><span>	cache.insert(<span style="color:#ae81ff">1</span>, std<span style="color:#f92672">::</span>make_shared<span style="color:#f92672">&lt;</span>CacheData<span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">1024</span>));
</span></span><span style="display:flex;"><span>	cache.insert(<span style="color:#ae81ff">2</span>, std<span style="color:#f92672">::</span>make_shared<span style="color:#f92672">&lt;</span>CacheData<span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">2048</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// get objects from cache and access methods of them
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (cache.contains(<span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		assert(cache.get(<span style="color:#ae81ff">1</span>)<span style="color:#f92672">-&gt;</span>size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">1024</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (cache.contains(<span style="color:#ae81ff">2</span>))
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		assert(cache.get(<span style="color:#ae81ff">2</span>)<span style="color:#f92672">-&gt;</span>size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">2048</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here you can see, that the <code>main()</code> implementation uses two steps to retrieve the cached value. First it checks whether it is available with <code>contains()</code> and then retrieves the value with <code>get()</code>. In an environment where the <code>Cache1</code> is only accessed by a single thread everything works just fine.</p>
<p><em>There might be some missing validation checks and capacity regulations in the <code>Cache1</code> class, but that is not the topic of this article.</em></p>
<h2 id="thread-safe-but-not-atomic">Thread-safe, but not atomic</h2>
<p>Lets see how it looks, when we apply the above mentioned simple way to make the class thread-safe.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cache2</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">mutable</span> std<span style="color:#f92672">::</span>mutex _mtx;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>CacheData<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> _map;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> contains(<span style="color:#66d9ef">int</span> key) <span style="color:#66d9ef">const</span>
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		std<span style="color:#f92672">::</span>lock_guard<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> l(_mtx);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">bool</span> b <span style="color:#f92672">=</span> _map.find(key) <span style="color:#f92672">!=</span> _map.end();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> b;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>CacheData<span style="color:#f92672">&gt;</span> get(<span style="color:#66d9ef">int</span> key) <span style="color:#66d9ef">const</span>
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		std<span style="color:#f92672">::</span>lock_guard<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> l(_mtx);
</span></span><span style="display:flex;"><span>		std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>CacheData<span style="color:#f92672">&gt;</span> val <span style="color:#f92672">=</span> _map.at(key); <span style="color:#75715e">// can throw an std::exception
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> val;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">int</span> key, std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>CacheData<span style="color:#f92672">&gt;</span> value)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		std<span style="color:#f92672">::</span>lock_guard<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> l(_mtx);
</span></span><span style="display:flex;"><span>		_map.insert(std<span style="color:#f92672">::</span>make_pair(key, value));
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>I only added a new <a href="http://www.cplusplus.com/reference/mutex/mutex/"><code>std::mutex</code></a> as class member and wrapped each method implementation with <code>_mtx.lock()</code> and <code>_mtx.unlock()</code>. This does make all access on the internal <a href="http://www.cplusplus.com/reference/map/map/"><code>std::map</code></a> absolutely thread-safe. The <code>Cache2</code> itself is now no longer the problem. The problem comes with the way the class is being used, because it still uses the same <code>main()</code> implementation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">**</span> argv)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// fill cache
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	Cache2 cache;
</span></span><span style="display:flex;"><span>	cache.insert(<span style="color:#ae81ff">1</span>, std<span style="color:#f92672">::</span>make_shared<span style="color:#f92672">&lt;</span>CacheData<span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">1024</span>));
</span></span><span style="display:flex;"><span>	cache.insert(<span style="color:#ae81ff">2</span>, std<span style="color:#f92672">::</span>make_shared<span style="color:#f92672">&lt;</span>CacheData<span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">2048</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// get objects from cache and access methods of them
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (cache.contains(<span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		assert(cache.get(<span style="color:#ae81ff">1</span>)<span style="color:#f92672">-&gt;</span>size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">1024</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (cache.contains(<span style="color:#ae81ff">2</span>))
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		assert(cache.get(<span style="color:#ae81ff">2</span>)<span style="color:#f92672">-&gt;</span>size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">2048</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>You might wonder, what could go wrong, even if two classes access the <code>Cache2</code> at the same time, the class is thread-safe though.</p>
<p>Even this is right, but looking closer in consideration of the <code>main()</code> implementation the code unveils some nasty behavior, which will crash the program under certain conditions. So whats the deal?</p>
<p>Lets imaging you have two threads: One inserts and reads (<code>get()</code>) values and the second thread removes values from cache. Now the following order may happen:</p>
<ul>
<li>Thread #1: Insert &ldquo;1&rdquo;</li>
<li>Thread #1: Insert &ldquo;2&rdquo;</li>
<li>Thread #1: Checks with <code>contains(1)</code> and returns <code>true</code></li>
<li>Thread #2: Removes &ldquo;1&rdquo;</li>
<li>Thread #1: Gets object &ldquo;1&rdquo; from cache and calls a method on tries to access an attribute; <strong>Crash!!!</strong></li>
</ul>
<p>Here is the problematic piece of code again:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (cache.contains(<span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// -&gt; here thread #2 removes value &#34;1&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// -&gt; this is possible because the `Cache2::_mtx` is no longer locked
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// now thread #1 directly accesses the no longer existing object and crashes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		assert(cache.get(<span style="color:#ae81ff">1</span>)<span style="color:#f92672">-&gt;</span>size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">1024</span>);
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><p>As you can see, because the two calls to <code>contains()</code> and <code>get()</code> are not atomic is why this <code>Cache2</code> implementation is not really thread-safe.</p>
<blockquote>
<p><strong>Side node:</strong> In reality the crash would already happen inside <code>Cache2::get()</code>, because <a href="http://www.cplusplus.com/reference/map/map/at/"><code>std::map::at()</code></a> method throws an exception, if the key is not available.</p>
</blockquote>
<h2 id="thread-safe-locking-the-right-way">Thread-safe locking, the right way</h2>
<p>Now we take a look at an implementation, which is not only thread-safe but also atomic with all of its methods.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cache3</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">mutable</span> std<span style="color:#f92672">::</span>mutex _mtx;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>CacheData<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> _map;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>CacheData<span style="color:#f92672">&gt;</span> get(<span style="color:#66d9ef">int</span> key) <span style="color:#66d9ef">const</span>
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		std<span style="color:#f92672">::</span>lock_guard<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> l(_mtx);
</span></span><span style="display:flex;"><span>		std<span style="color:#f92672">::</span>map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>CacheData<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;::</span>const_iterator it;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> ((it <span style="color:#f92672">=</span> _map.find(key)) <span style="color:#f92672">!=</span> _map.end())
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">auto</span> val <span style="color:#f92672">=</span> it<span style="color:#f92672">-&gt;</span>second;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> val;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>CacheData<span style="color:#f92672">&gt;</span>();
</span></span><span style="display:flex;"><span>	} <span style="color:#75715e">// auto unlock (lock_guard, RAII)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">int</span> key, std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>CacheData<span style="color:#f92672">&gt;</span> value)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		std<span style="color:#f92672">::</span>lock_guard<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> l(_mtx);
</span></span><span style="display:flex;"><span>		_map.insert(std<span style="color:#f92672">::</span>make_pair(key, value));
</span></span><span style="display:flex;"><span>	} <span style="color:#75715e">// auto unlock (lock_guard, RAII)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><p>The important change here is, that the check whether a value is in cache, is within the same LOCK as the method to retrieve the cached value. But not only the class changes, also the implementation of the <code>main()</code> needs to be different now.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">**</span> argv)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// fill cache
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	Cache3 cache;
</span></span><span style="display:flex;"><span>	cache.insert(<span style="color:#ae81ff">1</span>, std<span style="color:#f92672">::</span>make_shared<span style="color:#f92672">&lt;</span>CacheData<span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">1024</span>));
</span></span><span style="display:flex;"><span>	cache.insert(<span style="color:#ae81ff">2</span>, std<span style="color:#f92672">::</span>make_shared<span style="color:#f92672">&lt;</span>CacheData<span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">2048</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// get objects from cache and access methods of them
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>CacheData<span style="color:#f92672">&gt;</span> val;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	val <span style="color:#f92672">=</span> cache.get(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (val)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		assert(val<span style="color:#f92672">-&gt;</span>size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">1024</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	val <span style="color:#f92672">=</span> cache.get(<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (val)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		assert(val<span style="color:#f92672">-&gt;</span>size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">2048</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Instead of calling two methods of <code>Cache3</code>, you only need to call <code>get()</code>. The return value will be valid, if it is cached or invalid if it is not in cache. You can add an <code>contains()</code> method again, of course, but never expect that <code>get()</code> returns a valid value as next statement.</p>
<p>This was only a small example to show what can go wrong with thread-safe programming, but I hope it could help a bit.</p>
<p>Sources on GitHub: <a href="https://github.com/mfreiholz/post-threadsafeclass">https://github.com/mfreiholz/post-threadsafeclass</a></p>
<h1 id="update-notes">Update notes</h1>
<ul>
<li>Because of some feedback, I decided to use <code>std::lock_guard</code> for safe RAII based mutex locking. I didn&rsquo;t use it in the first place, because I thought it could be more transparent for presentation purpose to use basic <code>std::mutex::lock()</code> and <code>std::mutex::unlock()</code> calls. <em>Bret Kuns</em> made it clear to me, that a reader have to understand RAII and it&rsquo;s better to let the user google for it before showing it the wrong way.</li>
</ul></div>
	
	<div class="post-tags">
		
			<a href="/tags/development">Development</a> /
		
			<a href="/tags/tutorial">Tutorial</a> /
		
			<a href="/tags/c&#43;&#43;">C&#43;&#43;</a> /
		
		Oct 16 2016
	</div>
</div>

		<div class="post-comments"> 
			<div id="disqus_thread"></div>
<script>
	


	

	var disqus_config = function () {
		this.page.url = 'https://mfreiholz.de\/posts\/make-a-class-thread-safe-cpp\/';  
		
	};
	(function() {  
		
		
		

		var d = document, s = d.createElement('script');
		s.src = '//mfreiholz.disqus.com/embed.js';
		s.setAttribute('data-timestamp', +new Date());
		(d.head || d.body).appendChild(s);
	})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

		</div>
	</div>


	<div class="site-footer">
		<section>
			<div><a href="/impressum/">Disclaimer / Impressum</a></div>
		</section>
		<section>
			Made with &#9825; mfreiholz.de
		</section>
		<section>
			<div>&#105;&#110;&#102;&#111;&#064;&#109;&#102;&#114;&#101;&#105;&#104;&#111;&#108;&#122;&#046;&#100;&#101;</div>
			<div></div>
		</section>
	</div>

	
	
	
	<link rel="stylesheet" href="https://mfreiholz.de/style.css" integrity="">

	
	<link rel="stylesheet" type="text/css" href="/markdown.css">

	
	
	

</body>

</html>
